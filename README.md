# OPTiMAL

This directory contains code to predict sea surface temperature (SST) from the relative abundances of isoGDGTs using a Gaussian Process Regression (GPR) as described in:

*[OPTiMAL: A new machine learning approach for GDGT-based palaeothermometry](https://doi.org/10.5194/cp-16-2599-2020)\
Tom Dunkley Jones, Yvette L. Eley, William Thomson, Sarah E. Greene, Ilya Mandel, Kirsty Edgar, and James A. Bendle\
Climate of the Past 16, 2599–2617, 2020. doi:10.5194/cp-16-2599-2020.*

This directory provides an updated version of the original code (OPTiMAL), keeping the fundamental method and built-in nearest neighbour distance screening, but extending the code to analyse GPR length-scale adjusted dimensions. The GPR analysis is provided in MATLAB in order to preserve a consistent analytical approach with MATLAB's implementation of the fitrgp function. Analysis of the MATLAB outputs is provided in a series of Python functions that enable the complete recreation of all figure presented in the manuscript (MANUSCRIPT TITLE and JOURNAL)…

## Getting Started

This repository contains all of the code and files you will need to run both the GPR model and the Python code. Start by downloading or cloning this repository in its entirety. The contents are as follows:

**READ.md**: The readme you are currently reading.\
**OPTiMAL_MATLAB_2024.m**: Calculates temperature, predictive error and the weighted nearest neighbour distances using the GPR model.\
**OPTiMAL_Python.py**: Post GPR workup of the data. A short Python script that pulls functions from a separate file to make for a less cluttered user experience
**OPTiMAL_Function.py**: Functions required to execute the file OPTiMAL_Python.py. 5 principle functions are provided and fully commented in the Python file, but an overview is provided here: 
1) Return_Slice_of_Distance_df: Ingests the weighted nearest neighbour distances generated by the GPR and returns a slice of the matrix. E.g. slicing for the smallest value would return the D_Nearest screening metric utilised in OPTiMAL.
2) Make_Calibration_Map: Returns the maps of Figure 1, REF TO MANUSCRIPT. Calibration data are 	shown coloured by the chosen D_Values (default = median) to highlight spatial and temporal 	variations in how data contribute to a GPR prediction.
3) OPTiMAL_SST_Timeseries: Returns the SST timeseries of Figure 2, REF TO MANUSCRIPT. 
4) OPTiMAL_DValues_Timeseries: Returns the D_Value timeseries of Figure 3, REF TO MANUSCRIPT.
5) ODP_1168_1172: Returns the site specific (ODP 1168 and 1172, Tasmania) timeseries of Figure 	4, REF TO MANUSCRIPT.

**Global_Calibration.csv**: Recommended modern calibration dataset (default setting), combining the full core-top data of [Tierney & Tingley (2015)](https://doi.org/10.1038/sdata.2015.29) with additional data from [Seki et al. (2014)], as per OPTiMAL (2020).
**Example_Holocene.csv**: A subset of the ancient data compilation from the Holocene.
**OPTiMAL_MATLAB_2024.asv**: The MATLAB state after funning the code on the "Example_Holocene.csv" data. All inputs and outputs are viewable without needed to run the code.
**Ancient_Data_Compilation.csv**: The full ancient data compilation (n=12,256) in a format that will run directly in OPTiMAL.
**Ancient_Data_Compilation_Master.xlsx**: The master Excel spreadsheet containing all data compilation (site summaries, epoch-by-epoch data, data references, and age model references).
**OPTiMAL_Output_Holocene.xlxs**: Results of OPTiMAL running the "Example_Holocene.csv".
**OPTiMAL_Output_All_Epochs.xlxs**: Results of OPTiMAL running the "Ancient_Data_Compilation.csv". 
**OPTiMAL_Output_ODP1168.xlxs**: Results of OPTiMAL running on the data from ODP core 1168.
**OPTiMAL_Output_ODP1172.xlxs**: Results of OPTiMAL running on the data from ODP core 1172.

## Prerequisites
### GPR model ('OPTiMAL')
Running the GPR model will require MATLAB (back compatible to version 2015b). 

* [MATLAB](https://mathworks.com/products/matlab.html)

### Python Code
Running the Python code requires a Python environment with the following packages:
* os
* matplotlib
* numPy
* pandas
* statsmodels
* cartopy

It is recommended to access Python via Anaconda. Of these packages, only "cartopy" is not installed by default as part of Anaconda. To install cartopy via the terminal: 

	conda install -c cartopy

## Running the code:
### GPR model ('OPTiMAL_Matlab_2024')

Open and run the OPTiMAL_Matlab_2024.m code. This will load the provided calibration data:

'''
Global_Calibration.csv
'''

and the example ancient data: 

'''
Example_Holocene.csv
'''

and output:

'''
OPTiMAL_Output.xlsx
'''

The output is an Excel workbook, containing 4 sheets of data:
1). Calibration_Dataset_matlab Sheet: The input calibration data with GPR temperature predictions made on the known dataset, allowing for an assessment of model performance to be made.
2). Ancient_Dataset_matlab Sheet: The input ancient data with GPR temperature predictions, predictive error estimates, and D_Nearest screening values (Closest distance between the lengthscale weighted ancient and calibration datapoints. Used as a QC measure where SST predictions are only considered robust when D_Nearest <= 0.5).
3). Sigma_matlab Sheet: The GPR learned lengthscales for each dimension of the dataset. Listed in order of the input_variables in the MATLAB code.
4). Distance_Array_matlab Sheet: A matrix of all D_Values (distance between the lengthscale weighted  ancient and calibration datapoints). The dimensions of the matrix are the size of the calibration data x ancient data (calibration = excel columns, ancient = excel rows). D_Nearest represents the smallest value of a given row of data (i.e. the closest calibration datapoint to a given ancient datapoint).

To predict temperatures from a new dataset, format the column headers for the fractional isoGDGT abundances in the same style as the "Global_Calibration.csv". Save your data as a .csv file in the same directory as the MATLAB code. Open the MATLAB code and adjust the "~~~ User Inputs ~~~" to match your file names/column headers. Run the MATLAB code.

### Python Code ('OPTiMAL_Python'):

Open and run the OPTiMAL_Python.py code. This will ingest the outputs of the MATLAB GPR model:

'''
OPTiMAL_Output.xlsx
'''

and return the figures and underlying data presented in REF TO MANUSCRIPT.

To use this code, open the OPTiMAL_Python.py file. A series of generalised functions are called from a separate script (OPTiMAL_Functions.py) to streamline the amount of code the user has to interact with. Fully commented code is provided in "OPTiMAL_Functions.py" detailing all inputs and outputs for every function. Ensure the OPTiMAL_Output.xlsx is saved in the same directory as the .py script. D_value metric is generated using the function "Return_Slice_of_Distance_df". For all figure plotting functions, "save_fig = True/False" can be used to save the output of figure plotting as both a .png and .svg file. 

## Publishing outputs from this code

Publications using this code should cite both Allison et al., 2024 andDunkley Jones et al., 2020 in addition to this github repository. The Following data are required to ensure your work is reproducible:
1) Full relative abundance data for all 6 GDGT compounds
2) Citation of modern calibration dataset used
3) Publication of full calibration dataset if it has not been previously published elsewhere

## Authors

* Matthew Allison
* Ilya Mandel
* Will Thomson
* Sarah Greene

